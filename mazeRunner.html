<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maze Runner</title>
  <style>
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      background: linear-gradient(to right, #282c34, #1a1d23);
      color: #fff;
    }

    header {
      background: linear-gradient(to right, #4e54c8, #8f94fb);
      padding: 10px;
      text-align: center;
    }

    section {
      padding: 20px;
      text-align: center;
    }

    video {
      max-width: 100%;
      height: auto;
    }

    textarea {
      width: 100%;
      height: 300px;
      margin-top: 20px;
      background: #333;
      color: #fff;
      padding: 10px;
      border: none;
      border-radius: 5px;
    }
  </style>
</head>
<body>

  <header>
    <h1>Maze Runner App</h1>
  </header>

  <section>
    <h2>Maze Runner App in Action</h2>
    <video loop controls>
      <source src="Maze runner video.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <h2>Code</h2>
    <textarea readonly>
      This is the code for the above Maze runner application this code below, 
      you'll be able to recreate the Maze runner application 
     <!--  // MazeRunner.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
using namespace std;
#include <Windows.h>
#include <chrono>
#include <vector>
#include <algorithm>

int nScreenWidth = 120;
int nScreenHeight = 40; 


// we dont want the player to move around the maze on a tile by tile basis
   // as this is quite slow, x and y represent the players coordinates a is the
   //angle the player is facing 
float fPlayerX = 8.0f;
float fPlayerY = 8.0f;
float fPlayerA = 0.0f;

int nMapHeight = 16;
int nMapWidth = 16;

//crating a field of view variable so we can determine the distances from the wall
// as well as what the maze runner can see 
float fFOV = 3.14159 / 4.0;
float fDepth = 16.0f; 

int main()
{
    //create the screen buffer using the windows class library 
    wchar_t *screen = new wchar_t[nScreenWidth * nScreenHeight]; 
    HANDLE hConsole = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
        0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL);
    //letting the buffer know it will be the target of our console 
    SetConsoleActiveScreenBuffer(hConsole);
    DWORD dwBytesWritten = 0;

    // map wstring for type unicode
    wstring map;


    map += L"################"; 
    map += L"#..............#";
    map += L"#..............#";
    map += L"#..............#";
    map += L"#..........#...#";
    map += L"#..........#...#";
    map += L"#..........#...#";
    map += L"#..........#...#";
    map += L"#..........#...#";
    map += L"#..............#";
    map += L"#..............#";
    map += L"#..............#";
    map += L"#........#######";
    map += L"#..............#";
    map += L"#..............#";
    map += L"################";


    //chrono library objects used to measure time 
    auto tp1 = chrono::system_clock::now();
    auto tp2 = chrono::system_clock::now();


    //Game loop 
    while (1) {

        //measure a duration 
        tp2 = chrono::system_clock::now();
        chrono::duration<float> elapsedTime = tp2 - tp1; 
        tp1 = tp2; 
        float fElapsedTime = elapsedTime.count();
        
        //shortcut hacks for controls 
        //hand the ccw rotations of the maze runner 
        // normal keys used for rotation left and right in first person shooters 
        if (GetAsyncKeyState((unsigned short)'A') & 0x8000)
        {
            fPlayerA -= (0.7f) * fElapsedTime; //multiply by the rime elapsed to reduce 
                                                //rotation speed 
        }

        if (GetAsyncKeyState((unsigned short)'D') & 0x8000)
        {
            fPlayerA += (0.7f) * fElapsedTime; //multiply by the rime elapsed to reduce 
                                                //rotation speed 
        }

        //this code below makes the character move forward 
        if (GetAsyncKeyState((short)'W') & 0x8000)
        {
            fPlayerX += sinf(fPlayerA) * 5.0f * fElapsedTime;
            fPlayerY += cosf(fPlayerA) * 5.0f * fElapsedTime;

            //this is the collision detection rule 
            // which simply moves back when the wall is hit, just undo the previous move and move back from the wall once 
            if (map[(int)fPlayerY * nMapWidth + (int)fPlayerX] == '#')
            {
                fPlayerX -= sinf(fPlayerA) * 5.0f * fElapsedTime; 
                fPlayerY -= cosf(fPlayerA) * 5.0f * fElapsedTime;
            }
        }

        //this makes the player move backwards 
        if (GetAsyncKeyState((short)'S') & 0x8000)
        {
            fPlayerX -= sinf(fPlayerA) * 5.0f * fElapsedTime;
            fPlayerY -= cosf(fPlayerA) * 5.0f * fElapsedTime;

            //this simply does the same as the top collision detection instead of moving back it moves forward 
            if (map[(int)fPlayerY * nMapWidth + (int)fPlayerX] == '#')
            {
                fPlayerX += sinf(fPlayerA) * 5.0f * fElapsedTime;
                fPlayerY += cosf(fPlayerA) * 5.0f * fElapsedTime;
            }
        }

        for (int x = 0; x < nScreenWidth;x++)
        {
            //calculates the projected ray angle per column for the maze space 
            float fRayAngle = (fPlayerA - fFOV / 2.0f) + ((float)x / (float)nScreenWidth) * fFOV;

            // test the distance to the wall and see what the distance between 
            // the player and the wall using a retracing method, though repetitive
            // and inefficient its the simplest method 
            float fDistanceToWall = 0; 
            bool bHitWall = false; // the variable that determines whether the maze runner has hit the wall or not 
            bool bBoundary = false; // is it the edge of the cell, so we can verify what the player can actually see


            // the 2 below variables represent the unit vector in the player space. 
            float fEyeX = sinf(fRayAngle); 
            float fEyeY = cos(fRayAngle);

            // this checks that our distance to hit the wall is not met and that its less than 
            // the depth of the wall or screen, to prevent endless calculation
            // in the event its an open space 
            while (!bHitWall && fDistanceToWall < fDepth)
            {
                fDistanceToWall += 0.1f; 

                // this the line that checks the distance with regards to the distance from the wall 
                int nTestX = (int)(fPlayerX + fEyeX * fDistanceToWall);
                int nTestY = (int)(fPlayerY + fEyeY * fDistanceToWall);

                // the if statement below checks to ensure we are not out of bound
                if (nTestX < 0 || nTestX >= nMapWidth || nTestY < 0 || nTestY >= nMapHeight)
                {
                    // this sets the distance to the wall at max depth 
                    bHitWall = true;
                    fDistanceToWall = fDepth; 
                }
                else
                {
                    // this verfies the Rays inbounds test to see if the ray cell is a wall  
                    if (map[nTestY * nMapWidth + nTestX] == '#')
                    {
                        bHitWall = true; // this exits the loop as the distance from the wall is now the last value contained and exits the loop
                        vector<pair<float, float>> p; // stores distance to the perfect corner by calculating the dot product 

                        //create 2 loops to determine a pair of corners coordinates 
                        for(int tx=0; tx<2; tx++)
                            for (int ty = 0; ty < 2; ty++)
                            {
                                // gets the vector from the perfect corner 
                                float vy = (float)nTestY + ty - fPlayerY;
                                float vx = (float)nTestX + tx - fPlayerX;
                                float d = sqrt(vx * vx + vy * vy); // calculates the length of the vector 
                                float dot = (fEyeX * vx / d) + (fEyeY * vy / d); // this is the dot product 
                                p.push_back(make_pair(d, dot)); // creates the vector 
                            }

                        //sorts the pairs from closest to furthest 
                        sort(p.begin(), p.end(), [](const pair<float, float>& left, const pair<float, float>& right) {return left.first < right.first; });

                        //determines the angle this prepers the calculation of the distance 
                        float fBound = 0.01; 
                        if (acos(p.at(0).second) < fBound)
                            bBoundary = true; 
                        if (acos(p.at(1).second) < fBound)
                            bBoundary = true; 
                        if (acos(p.at(2).second) < fBound)
                            bBoundary = true;
                    }
                }
            }

            //the function below calculates the distance from maze runner to the ceiling and floor 
            // as the distance to wall gets larger we get a higher ceiling 
            int nCeiling = (float)(nScreenHeight / 2.0) - nScreenHeight / ((float)fDistanceToWall); 
            int nFloor = nScreenHeight - nCeiling; 


            //create some shading, depending on the distance from the wall
            short  nShade = ' ';

            //create the condition that determines the walls darkness 
            if (fDistanceToWall <= fDepth / 4.0f)
            {
                nShade = 0x2588; // this is a creates a ligher shade indicating a closer distance to the wall
            }
            else if (fDistanceToWall <= fDepth / 3.0f)
            {
                nShade = 0x2593;
            }
            else if (fDistanceToWall <= fDepth / 2.0f)
            {
                nShade = 0x2592;
            }
            else if (fDistanceToWall <= fDepth )
            {
                nShade = 0x2591;
            }
            else 
            {
                nShade = ' '; //this is a much darker shade indicating far distance away form the maze runner
            }

            if (bBoundary)		nShade = ' '; // Black it out
            
            // drawing of the ceiling and floor which are identical in our case 
            for (int y = 0; y < nScreenHeight; y++)
            {
                if (y <= nCeiling)
                {
                    screen[y * nScreenWidth + x] = ' ';
                }
                else if(y > nCeiling && y <= nFloor)
                {
                    screen[y * nScreenWidth + x] = nShade;
                }
                else
                {
                    //using the shade parameters to shade the floor 
                    float b = 1.0f - (((float)y - nScreenHeight / 2.0f) / ((float)nScreenHeight / 2.0f));
                    if (b < 0.25)
                    {
                        nShade = '#';
                    }
                    else if(b < 0.5)
                    {
                        nShade = 'x';
                    }
                    else if (b < 0.75)
                    {
                        nShade = '.';
                    }
                    else if (b < 0.9)
                    {
                        nShade = '-';
                    }
                    else
                    {
                        nShade = ' ';
                    }
                    screen[y * nScreenWidth + x] = nShade;
                }
            }
        }


        //to write to the screen we use, this is essentially the screen array with the escape 
        // character shown below to see the see the end of the area 
        screen[nScreenWidth * nScreenHeight - 1] = '\0';
        WriteConsoleOutputCharacter(hConsole, screen, nScreenWidth * nScreenHeight,
            { 0,0 }, &dwBytesWritten);

        // Display Stats the where the maze runner is the angle is facing and the frame rate 
        swprintf_s(screen, 40, L"X=%3.2f, Y=%3.2f, A=%3.2f FPS=%3.2f ", fPlayerX, fPlayerY, fPlayerA, 1.0f / fElapsedTime);

        // Display Map
        for (int nx = 0; nx < nMapWidth; nx++)
            for (int ny = 0; ny < nMapWidth; ny++)
            {
                screen[(ny + 1) * nScreenWidth + nx] = map[ny * nMapWidth + nx];
            }
        screen[((int)fPlayerX + 1) * nScreenWidth + (int)fPlayerY] = 'P';

        // Display Frame
        screen[nScreenWidth * nScreenHeight - 1] = '\0';
        WriteConsoleOutputCharacter(hConsole, screen, nScreenWidth * nScreenHeight, { 0,0 }, &dwBytesWritten);
    }
    return 0; 
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
// adapted from  Javidx9 first person shooter -->
    </textarea>
  </section>

</body>
</html>
